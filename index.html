<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* {
  box-sizing: border-box;
}

html, body {
  height: 100%;
}

body {
  display: flex;
  flex-direction: column;
  margin: 0;
  padding: 8px;
  font-family: monospace;
  color: white;
  background-color: black;
}

#output .prompt-response {
  padding: 1em 0;
  color: gray;
}

#output {
  flex: 1;
  white-space: pre-wrap;
  overflow-y: scroll;
}

#form {
  display: flex;
  align-items: center;
  padding-top: 8px;
}

#prompt {
  white-space: pre;
}

label, input {
  font-family: inherit;
  font-size: inherit;
  color: inherit;
  background: inherit;
}

#input {
  flex: 1;
  border: none;
}
</style>
<title>Werewolves and Wanderer</title>
<body>
<div id="output"></div>
<form id="form"><label id="prompt" for="input"></label><input id="input" autofocus></form>
<script>
"use strict";

const outputEl = document.getElementById('output');
const promptEl = document.getElementById('prompt');
const inputEl = document.getElementById('input');
const formEl = document.getElementById('form');

let _currentInput = null;
let _currentPrompt = promptEl.textContent;

// This is a hack that allows us to make it seem as though the program
// is "sleeping" when it wants to: because delays are only used for dramatic
// effect, we'll use a promise to buffer I/O and prevent the user from
// seeing any output (or sending any input) until time has passed. In
// reality, however, the program is running without actually sleeping,
// unlike its synchronous command-line counterpart.
let _currentPromise = Promise.resolve();

// This is called from Rust when the program wants to sleep. See above
// for an explanation of how we fake this.
window.sleep = ms => {
  _currentPromise = _currentPromise.then(() => {
    inputEl.disabled = true;
    return new Promise(resolve => {
      window.setTimeout(() => {
        inputEl.disabled = false;
        resolve();
      }, ms);
    });
  });
};

// Called from Rust code when it wants to prompt the user for input.
window.set_prompt = prompt => {
  _currentPromise.then(() => {
    if (prompt !== _currentPrompt) {
      promptEl.textContent = _currentPrompt = prompt;
    }
  });
};

// Called from Rust code when it wants to know if the user has
// typed a line of input and pressed return.
window.has_input = () => {
  return _currentInput === null ? 0 : 1;
};

window.set_input = val => {
  _currentPromise.then(() => {
    _currentInput = typeof(val) === 'string' ? val.trim() : val;
  });
};

// Called from Rust code when it wants to retrieve the user's line
// of input. This is a destructive operation, in that subsequent calls
// will return `null` until the user enters another line of input.
window.get_input = () => {
  const input = _currentInput;
  _currentInput = null;
  return input;
};

window.scroll_output = () => {
  outputEl.scrollTop = outputEl.scrollHeight;
};

window.Module = {
  // This is ultimately called by any Rust code that writes to
  // stdout.
  print(msg) {
    _currentPromise.then(() => {
      const textNode = document.createTextNode(msg + '\n');
      outputEl.appendChild(textNode);
      window.scroll_output();
    });
  }
};

formEl.addEventListener('submit', e => {
  e.preventDefault();

  const el = document.createElement('div');

  el.setAttribute('class', 'prompt-response');
  el.textContent = `${_currentPrompt}${inputEl.value}`;
  outputEl.appendChild(el);
  window.scroll_output();

  window.set_input(inputEl.value);
  inputEl.value = "";
});

window.addEventListener('DOMContentLoaded', () => {
  const script = document.createElement('script');
  const scriptName = 'werewolves-and-wanderer';
  let suffix = '.js';

  if (!window.WebAssembly) {
    suffix = '.asm.js';
  }

  script.setAttribute('src', scriptName + suffix);
  document.body.appendChild(script);
});
</script>
</body>
